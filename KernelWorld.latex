\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
    \setmainfont[]{AR PL New Sung}
    \usepackage{xeCJK}
    \setCJKmainfont[BoldFont=WenQuanYi Zen Hei,ItalicFont=STFangsong,Scale=1.0]{AR PL New Sung}
    \setlength{\parindent}{0pt} % 設定縮排
	\linespread{1.3} % 設定行距
	\setlength{\parskip}{16pt} % 設定段落間距    
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdftitle={阿男的Linux内核世界},
            pdfauthor={阿男},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
\newcommand{\ImportTok}[1]{{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
\newcommand{\BuiltInTok}[1]{{#1}}
\newcommand{\ExtensionTok}[1]{{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{阿男的Linux内核世界}
\author{阿男}
\date{Dec 22, 2016}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{2}
\tableofcontents
}
\chapter{进程}\label{ux8fdbux7a0b}

\section{Parent Process与Child
Process}\label{parent-processux4e0echild-process}

这篇文章我们接着学习Process。我们学习了fork()函数，并且写了sample
code来使用fork()函数创建一个child process：

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* exit() */}
\PreprocessorTok{#include }\ImportTok{<stdlib.h>}

\PreprocessorTok{#include }\ImportTok{<sys/types.h>}

\CommentTok{/*}
\CommentTok{ * fork()}
\CommentTok{ */}
\PreprocessorTok{#include }\ImportTok{<unistd.h>}

\CommentTok{/* }
\CommentTok{ * stderr}
\CommentTok{ * stdout}
\CommentTok{ * fprintf}
\CommentTok{ */}
\PreprocessorTok{#include }\ImportTok{<stdio.h>}

\DataTypeTok{void} \NormalTok{err_sys(}\DataTypeTok{const} \DataTypeTok{char}\NormalTok{* fmt, ...);}

\DataTypeTok{int} \NormalTok{main () \{}
    \NormalTok{pid_t pid;}
    \ControlFlowTok{if} \NormalTok{((pid = fork()) < }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* 创建child process */}
        \NormalTok{err_sys(}\StringTok{"fork error"}\NormalTok{);}
    \NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if} \NormalTok{(pid == }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* 这里是child process */}
        \NormalTok{puts(}\StringTok{"child process here."}\NormalTok{); }
        \NormalTok{puts(}\StringTok{"child process will sleep for 10 seconds..."}\NormalTok{);}
        \NormalTok{sleep(}\DecValTok{10}\NormalTok{);}
    \NormalTok{\} }\ControlFlowTok{else} \NormalTok{\{ }\CommentTok{/* 这里是parent process */}
        \NormalTok{puts(}\StringTok{"parent process here."}\NormalTok{);}
        \NormalTok{printf(}\StringTok{"parent get the child pid: %d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, pid);}
    \NormalTok{\}}
    
    \CommentTok{/* 父亲孩子共用的代码部分 */}
    \NormalTok{sleep(}\DecValTok{3}\NormalTok{);}
    
    \ControlFlowTok{if} \NormalTok{(pid == }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* child process */}
        \NormalTok{puts(}\StringTok{"child process exit."}\NormalTok{);}
    \NormalTok{\} }\ControlFlowTok{else} \NormalTok{\{ }\CommentTok{/* parent process */}
        \NormalTok{puts(}\StringTok{"parent process exit."}\NormalTok{);}
    \NormalTok{\}}
    
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void} \NormalTok{err_sys(}\DataTypeTok{const} \DataTypeTok{char}\NormalTok{* fmt, ...) \{}
    \NormalTok{va_list ap;}
    \NormalTok{fprintf(stderr, fmt, ap);}
    \NormalTok{exit(}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

这篇文章里面，我们就仔细地分析一下这段代码的执行过程。首先把它编译成可执行文件：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ cc process.c -o process}
\end{Highlighting}
\end{Shaded}

编译完成后，我们把代码执行起来：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ ./process }
\ExtensionTok{parent} \NormalTok{process here.}
\ExtensionTok{parent} \NormalTok{get the child pid: 22418}
\ExtensionTok{child} \NormalTok{process here.}
\ExtensionTok{child} \NormalTok{process will sleep for 10 seconds...}
\end{Highlighting}
\end{Shaded}

然后马上用\texttt{ps}命令来查看process的运行情况：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ ps -ef }\KeywordTok{|} \FunctionTok{grep} \NormalTok{process }\KeywordTok{|} \FunctionTok{grep} \NormalTok{-v grep}
\ExtensionTok{weli}     \NormalTok{22417 18153  0 21:00 pts/2    00:00:00 ./process}
\ExtensionTok{weli}     \NormalTok{22418 22417  0 21:00 pts/2    00:00:00 ./process}
\end{Highlighting}
\end{Shaded}

如上所示，我们可以用ps看到parent和child两个process。并且从日志和ps的输出可以看出
来，编号为22418的是child
process，它的parent是id为22417的process。因为我们写的代码是让parent
process先退出，然后child要多等10秒再推出，因此我们可以看看parent
process退出后，child process的状态是什么样子的：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ ps -ef }\KeywordTok{|} \FunctionTok{grep} \NormalTok{process }\KeywordTok{|} \FunctionTok{grep} \NormalTok{-v grep}
\ExtensionTok{weli}     \NormalTok{22418     1  0 21:00 pts/2    00:00:00 ./process}
\end{Highlighting}
\end{Shaded}

从上面的输出可以看到，如果我们等到parent process退出，而child
process没有退出的时候，此时ps用查看，就可以正在运行的process只有一个了。而且我们
看此时这个在运行的child process，它的ppid变成了1。也就是说，因为parent
process已经退出不存在了，所以1号进程称为了child
process的parent，这是内核对process继承关系的管理办法。最后我们看一下，等到两个进
程都执行完后的状态：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ ./process }
\ExtensionTok{parent} \NormalTok{process here.}
\ExtensionTok{parent} \NormalTok{get the child pid: 22618}
\ExtensionTok{child} \NormalTok{process here.}
\ExtensionTok{child} \NormalTok{process will sleep for 10 seconds...}
\ExtensionTok{parent} \NormalTok{process exit.}
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ child process exit.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ ps -ef }\KeywordTok{|} \FunctionTok{grep} \NormalTok{process }\KeywordTok{|} \FunctionTok{grep} \NormalTok{-v grep}
\end{Highlighting}
\end{Shaded}

可以看到，此时ps已经看不到parent和child两个process了，因为它们都执行完成了。

\subsection{小结}\label{ux5c0fux7ed3}

我们在这篇文章里看到了parent和child
process的执行过程。并且我们知道了，如果parent
process先退出，那么还在执行的child process的parent
process就变成了1号process。下篇文章中，阿男给大家讲反过来的情况，就是child
process先结束的情况。

\section{僵尸进程}\label{ux50f5ux5c38ux8fdbux7a0b}

这篇文章里面，阿男仍然是接续上一篇的内容，带大家继续学习Process。上一篇文章里我
们使用了一段代码来展示了parent process和child
process的关系：我们看到了parent process退出后，还在运行的child
process的parent变成了pid为1的process。那如果是child
process先退出，会是什么情况呢？我们这篇文章就讨论这种情况。这次我们要用到的代码
是这样的：

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* exit() */}
\PreprocessorTok{#include }\ImportTok{<stdlib.h>}

\PreprocessorTok{#include }\ImportTok{<sys/types.h>}

\CommentTok{/*}
\CommentTok{ * fork()}
\CommentTok{ */}
\PreprocessorTok{#include }\ImportTok{<unistd.h>}

\CommentTok{/* }
\CommentTok{ * stderr}
\CommentTok{ * stdout}
\CommentTok{ * fprintf}
\CommentTok{ */}
\PreprocessorTok{#include }\ImportTok{<stdio.h>}

\DataTypeTok{void} \NormalTok{err_sys(}\DataTypeTok{const} \DataTypeTok{char}\NormalTok{* fmt, ...);}

\DataTypeTok{int} \NormalTok{main () \{}
    \NormalTok{pid_t pid;}
    \ControlFlowTok{if} \NormalTok{((pid = fork()) < }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* create a process */}
        \NormalTok{err_sys(}\StringTok{"fork error"}\NormalTok{);}
    \NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if} \NormalTok{(pid == }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* child process */}
        \CommentTok{/* Child process直接退出 */}
        \NormalTok{exit (}\DecValTok{0}\NormalTok{); }
    \NormalTok{\} }\ControlFlowTok{else} \NormalTok{\{}
        \CommentTok{/* Parent process睡眠60秒，保证child process先退出*/}
        \NormalTok{fputs(}\StringTok{"parent process goes to sleep..."}\NormalTok{, stderr);}
        \NormalTok{sleep (}\DecValTok{60}\NormalTok{); }
    \NormalTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{// 错误处理函数}
\DataTypeTok{void} \NormalTok{err_sys(}\DataTypeTok{const} \DataTypeTok{char}\NormalTok{* fmt, ...) \{}
    \CommentTok{/* va_list 可变长参数，使用 `man stdarg` 命令学习相关文档。*/}
    \NormalTok{va_list ap;}
    \NormalTok{fprintf(stderr, fmt, ap);}
    \NormalTok{exit(}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

可以看到，我们这次所使用的代码其实和之前使用的差不多，而最大的区别就是，这次的代
码是child process先退出，然后parent process要sleep
60秒才退出。因此我们可以看看再这样的情况下，和child
process先退出会有什么不同。首先我们编译这段代码：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ cc zombie.c -o zombie}
\end{Highlighting}
\end{Shaded}

然后我们运行编译后的代码：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ ./zombie }
\ExtensionTok{parent} \NormalTok{process goes to sleep...}
\end{Highlighting}
\end{Shaded}

此时我们使用\texttt{ps}命令查看这个程序的两个process的运行状况：

\begin{verbatim}
[weli@fedora process]$ ps -ef | grep zombie
weli      9203  5502  0 19:53 pts/0    00:00:00 ./zombie
weli      9204  9203  0 19:53 pts/0    00:00:00 [zombie] <defunct>
\end{verbatim}

此时通过pid和ppid的关系可以看到，parent process的id是9203，child
process的id是9204。此时parent process在正常运行的状态，而child
process的状态是\texttt{\textless{}defunct\textgreater{}}。也就是说，child
process虽然已经退出了，但是它并没有完全消失，而是还留下了一个defunct状态的``壳''，
我们管这种状态的进程叫做zombie process，也就是僵尸进程。

为什么叫它zombie
process？因为这个process的资源已经已经被释放干净了，只是个没有生命力的空壳而已。
我们可以使用lsof命令来验证这点：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ lsof -p 9204}
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ }
\end{Highlighting}
\end{Shaded}

如上所示，我们使用lsof命令来查看这个zombie
process所使用的文件资源，因为只要是在运行的process，都会打开一些文件的，至少这个
process自身所对应的程序文件是一定要打开的。我们可以对比一下使用\texttt{lsof}命令查看正
在运行的parent process的情况：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\ExtensionTok{weli@fedora} \NormalTok{process]$ lsof -p 9203}
\ExtensionTok{COMMAND}   \NormalTok{PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME}
\ExtensionTok{zombie}  \NormalTok{9203 weli  cwd    DIR  253,2     4096 523330 }
\ExtensionTok{/home/weli/projs/kernel-learning/process}
\ExtensionTok{zombie}  \NormalTok{9203 weli  rtd    DIR  253,0     4096      2 /}
\ExtensionTok{zombie}  \NormalTok{9203 weli  txt    REG  253,2     8912 523335 }
\ExtensionTok{/home/weli/projs/kernel-learning/process/zombie}
\ExtensionTok{zombie}  \NormalTok{9203 weli  mem    REG  253,0  2093616 795514 /usr/lib64/libc-2.23.so}
\ExtensionTok{zombie}  \NormalTok{9203 weli  mem    REG  253,0   172080 795403 /usr/lib64/ld-2.23.so}
\ExtensionTok{zombie}  \NormalTok{9203 weli    0u   CHR  136,0      0t0      3 /dev/pts/0}
\ExtensionTok{zombie}  \NormalTok{9203 weli    1u   CHR  136,0      0t0      3 /dev/pts/0}
\ExtensionTok{zombie}  \NormalTok{9203 weli    2u   CHR  136,0      0t0      3 /dev/pts/0}
\end{Highlighting}
\end{Shaded}

从上面的输出可以看到，正在运行的parent
process至少在使用着自己所对应的程序文件\texttt{/home/weli/projs/kernel-learning/process\ /zombie}，而实际上已经退出的child
prorcess就是一个空壳，实实在在就是一个zombie！那么为什么child
process执行完成后，内核还要保留这样一个zombie
process呢？这个问题作为本篇文章的读后思考问题，阿男下篇文章为大家进行讲解。

\end{document}
